<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat No GPT</title>
</head>
<body>
  <script type="application/javascript">
    document.addEventListener("DOMContentLoaded", function() {
      // Creación de elementos: ul para mensajes, textarea, botón de envío y de cambio de tema
      const ul = document.createElement('ul');
      document.body.append(ul);

      const t = document.createElement('textarea');
      t.setAttribute('maxlength', '140');
      document.body.append(t);

      const charCount = document.createElement('div');
      charCount.className = 'char-count';
      document.body.append(charCount);

      const b = document.createElement('button');
      b.className = 'send-button';
      b.textContent = 'SEND';
      document.body.append(b);

      const themeToggle = document.createElement('button');
      themeToggle.textContent = 'Toggle Theme';
      document.body.append(themeToggle);

      // Definición de estilos para temas claro y oscuro
      const themes = {
        light: {
          body: { backgroundColor: '#ffffff', color: '#000000' },
          ul: { backgroundColor: '#FFF', color: '#000' },
          li: { backgroundColor: '#e7f3ff', color: '#000' },
          textarea: { backgroundColor: '#ffffff', color: '#000000', borderColor: '#ccc' },
          button: { backgroundColor: '#007bff', color: '#ffffff' },
          charCount: { color: '#777' },
          linkPreview: { color: '#007bff' }
        },
        dark: {
          body: { backgroundColor: '#181818', color: '#ffffff' },
          ul: { backgroundColor: '#242424', color: '#fff' },
          li: { backgroundColor: '#323739', color: '#fff' },
          textarea: { backgroundColor: '#333', color: '#ffffff', borderColor: '#444' },
          button: { backgroundColor: '#0056b3', color: '#ffffff' },
          charCount: { color: '#888' },
          linkPreview: { color: '#9ecfff' }
        }
      };

      // Función para aplicar estilos según el tema
      function applyStyles(theme) {
        const style = themes[theme];
        Object.assign(document.body.style, style.body);
        Object.assign(ul.style, style.ul);
        Object.assign(t.style, {
          position: 'fixed', left: '50%', transform: 'translateX(-50%)',
          bottom: '50px', width: 'calc(80% - 20px)', height: '40px',
          resize: 'none', borderRadius: '15px', outline: 'none', padding: '10px',
          ...style.textarea
        });
        Object.assign(b.style, {
          position: 'fixed', left: '50%', transform: 'translateX(-50%)',
          bottom: '15px', cursor: 'pointer', borderRadius: '15px',
          padding: '10px 20px', ...style.button
        });
        Object.assign(charCount.style, {
          position: 'fixed', left: '50%', transform: 'translateX(-50%)',
          bottom: '95px', ...style.charCount
        });
        // Estilos adicionales y eventos aquí...
      }

      // Cambio de tema y almacenamiento en localStorage
      const toggleTheme = () => {
        const currentTheme = localStorage.getItem('theme') === 'dark' ? 'dark' : 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        applyStyles(newTheme);
      };

      // Aplicar tema al cargar
      const savedTheme = localStorage.getItem('theme') || 'light';
      applyStyles(savedTheme);

      themeToggle.addEventListener('click', toggleTheme);

      const getMessages = async () => {
        const response = await fetch('https://chat.tiburoncin.lat/messages');
        const messages = await response.json().then(data => data.reverse());

        // Guarda la posición actual del scroll antes de actualizar los mensajes
        const atBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight;
        
        ul.innerHTML = ""; // Limpia la lista antes de agregar los nuevos mensajes para evitar duplicados
        messages.forEach((message) => {
          const li = document.createElement('li');
          li.classList.add('message-anim'); // Aplica la clase de animación si es necesario

          // Detecta y procesa ambos, URLs de imágenes y enlaces web
          let processedMessage = message.message.replace(/(https?:\/\/\S+)/g, (url) => {
            // Si es una imagen, retorna un elemento img
            if (url.match(/\.(jpg|jpeg|png|gif)$/)) {
              return `<img src="${url}" style="max-width: 200px; max-height: 200px;">`;
            } else {
              // Para otros enlaces, muestra el dominio como texto clickeable
              const domain = new URL(url).hostname;
              return `<a href="${url}" target="_blank" class="link-preview">${domain}</a>`;
            }
          });

          // Configura el contenido del mensaje, permitiendo HTML
          li.innerHTML = `${message.username}: ${processedMessage}`;
          ul.appendChild(li);
        });
        
        // Ajusta el scroll si el usuario estaba al final
        if (atBottom) {
          window.scrollTo(0, document.body.scrollHeight);
        }
      };


      setInterval(getMessages, 5000);


    const postMessage = async () => {
      console.log(t.value);
      const body = {
        username: 'Esteban Z',
        message: t.value,
      };

      // Evita limpiar inmediatamente para no perder la posición del scroll
      const response = await fetch('https://chat.tiburoncin.lat/messages', {
        method: 'POST',
        body: JSON.stringify(body)
      });

      // Recarga los mensajes sin limpiar previamente la lista
      await getMessages();

      // Verifica si el usuario está al final antes de enviar el mensaje
      const atBottomBeforeSending = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 1;

      if (atBottomBeforeSending) {
        // Asegura que el scroll se ajuste solo después de que la lista se haya actualizado
        setTimeout(() => {
          window.scrollTo(0, document.body.scrollHeight);
        }, 100); // Pequeña demora para asegurar que el DOM se haya actualizado
      }

      t.value = ''; // Limpia el campo de texto después de enviar
      charCount.innerHTML = '0 / 140'; // Restablece el contador de caracteres
    };


      // Evento para enviar el mensaje con Enter y permitir saltos de línea con Shift+Enter
      t.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault(); // Previene el salto de línea
          postMessage(); // Llama a la función para enviar el mensaje
        }
      });

      // Actualiza el contador de caracteres
      t.addEventListener('input', function() {
        charCount.innerHTML = `${t.value.length} / 140`;
      });

      b.addEventListener('click', postMessage);

      getMessages();
    });
  </script>
</body>
</html>